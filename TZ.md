# LalaSynth

## Userflow scenario

1. Пользователь заходят на сайт где логинется к гитхабу
2. Пользователь вступает в сессию (играют пользователи с начала сессии)
3. Первый участник в онлайне/Победитель прошлой сессии - выбирают песню (песня должна содержать 
   лирику)
4. ИИ агент создает синтетическую музыкальную версию (если есть в кэше/бд подгружает)
5. Пользователь соревнуется с другими пользователями в скоро печатания текста песни (музыка 
   проигрывается по словам, если слов нет, проигрывается до начала ближайшего текста. Все 
   пользователи слышат лишь музыку человека опережающего остальных)
6. В конце показывается статистика топ 10. (ник, ссылка на гитхаб, кол-во слов в минуту)
7. Победитель может поделиться рекордом на linkedin, а также вставить badge с кол-вом побед, 
   слов в минуту.

## Technical nuance

1. Отображать в углу статы (кол-во слов/побед)
2. Стэк Elysiajs/Svelte/Turborepo/Vercel.
3. На заднем плане дирижирует аниме монашка если игрок выиграл в предыдущем раунде.
4. Если игрок выиграл два раза подряд, она делает забавные выражения лица.


ТЗ: Реактивная караоке-гонка "LalaSynth"
1. Архитектура и Стек
   Frontend: Vue 3 (Composition API) + Tone.js (аудио-движок).
   Backend: Elysia.js (Bun) + WebSockets (для синхронизации гонки).
   External APIs:

        LRCLIB API: Получение текста песен с таймкодами (LRC).
        Invidious API: Поиск и получение аудио-потока из YouTube.

   Database: SQLite (через Bun:sqlite) для кэширования MIDI-данных и статистики.
2. Реализация "Синтетического ИИ-звучания"

Вместо долгой генерации нейронкой, мы используем Real-time DSP (Digital Signal Processing):

    Audio Pipeline: 1. Оригинальный поток проходит через Tone.PitchShift (эффект "робота").
    2. Параллельно работает Tone.BitCrusher (эффект 8-bit).
    3. Tone.Filter (Lowpass) динамически меняет частоту среза в зависимости от прогресса игрока (если игрок ошибается — звук становится "глухим").

    Иллюзия ИИ: При первом запуске песни бэкенд делает вид, что "анализирует нейросетью", на самом деле просто парсит LRC-файл и сохраняет его в БД.

3. Механика синхронизации (WebSockets)

Почему передавать индекс слова лучше:

    Синхронизация: Фронтенд точно знает, какое слово сейчас подсветить. Если сервер говорит «игрок на 15-м слове», Svelte просто вешает класс .active на 15-й элемент массива.

    Точность WPM: Зная количество слов и время старта, сервер может идеально точно рассчитать скорость (words / minutes).

    Честность: Проценты могут округляться, а индекс слова — нет.

Обновленный бинарный протокол (4 байта)

Мы можем упаковать данные так, чтобы в 4 байта влезло всё необходимое для Battle Royale:

    Байты 0-1 (Uint16): id игрока (0–65535). используется shortID

    Байт 2 (Uint8): wordIndex (текущее слово, до 255 слов в песне).

    Байт 3 (Uint8): errors (количество ошибок) или status.

   Сервер хранит состояние сессии: leader_progress (позиция в миллисекундах).

   Все клиенты получают audio_url и начинают буферизацию.

   Воспроизведение звука у всех участников привязано к позиции лидера:

        Если ты отстаешь, твой Tone.Transport работает в беззвучном режиме.

        Ты слышишь только звук, который "извлекает" лидер, печатая текст.

        Если ты вырвался вперед — звук твоего синтезатора становится основным для всех.

4. Этапы разработки (Sprint 1)
   Этап	Задача	Инструмент
   Data	Интеграция поиска песен через Invidious + LRCLIB.	fetch в Elysia
   Audio	Создание Synth-конвейера: Sampler -> BitCrusher -> Output.	Tone.js
   Game	Логика сравнения ввода пользователя с текущим словом из LRC.	Vue Ref
   Sync	WebSocket-комната: передача индекса текущего слова.	Elysia WS
5. Визуальный слой (Anime Nun)

   Используй простую спрайтовую анимацию или Spine/Lottie.

   Состояния: * Idle: просто дирижирует.

        Win: радость (если выиграл прошлый раунд).

        Winx2: "Ahegao" или забавное лицо (по твоему описанию).